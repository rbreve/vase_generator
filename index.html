<!DOCTYPE html>
<html>
<head>
    <title>Three.js Curve with GUI</title>
    <style>
        body { margin: 0; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script  type="module">
        import * as THREE from './three.module.js';
         import { RGBELoader } from './RGBELoader.js';
         import { OrbitControls } from './js/OrbitControls.js';

         // Assuming Three.js and dat.GUI are included in your HTML

let scene, camera, renderer, latheMesh, curve, cubeRenderTarget, controls;
let angularity = 10; // Initial value for angularity
let metalnes = 0.5;
let roughness = 0.5;
let clearcoat = 0.5;
let vaseMaterial;
let color = 0x00ff00;

const controlPoints = [
    new THREE.Vector3(-10, 2, 15),
    new THREE.Vector3(-5, 8, 6),
    new THREE.Vector3(5, 6, -7),
    new THREE.Vector3(10, 9, -20)
];

init();
animate();

function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(30, 20, 30);
    camera.lookAt(scene.position);

    renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1;
    document.body.appendChild(renderer.domElement);


    // OrbitControls setup
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; // Optional, but for a smoother damping effect
    controls.dampingFactor = 0.50;
    controls.screenSpacePanning = false;

 
    // Create a CatmullRomCurve3 and convert it to 2D points for LatheGeometry
    curve = new THREE.CatmullRomCurve3(controlPoints);
    const points2D = curve.getPoints(angularity).map(p => new THREE.Vector2(p.y, p.z));
    
    const points2DReversed = points2D.reverse();
    const geometry = new THREE.LatheGeometry(points2DReversed, 20);

    let envmaploader = new THREE.PMREMGenerator(renderer);
    latheMesh = new THREE.Mesh();
    // Inside the RGBELoader load callback
new RGBELoader().setPath('textures/').load('quarry_01_1k.hdr', function(hdrEquirect) {
    const hdrEquirectResult = envmaploader.fromEquirectangular(hdrEquirect);
    scene.environment = hdrEquirectResult.texture;

    let texture = new THREE.TextureLoader().load('t2.jpg'); 
    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(2, 2);

    vaseMaterial = new THREE.MeshPhysicalMaterial({
        clearcoat: 0.2,
        metalness: 0.2,
        roughness: 0.6,
        normalMap: texture,
        normalScale: new THREE.Vector2(0.15, 0.15),
        envMap: hdrEquirectResult.texture,
        side: THREE.DoubleSide,
    });
    console.log(vaseMaterial.specularColor);
    const points2D = curve.getPoints(angularity).map(p => new THREE.Vector2(p.y, p.z));
    const points2DReversed = points2D.reverse();
    const geometry = new THREE.LatheGeometry(points2DReversed, 20);

    latheMesh.geometry = geometry;
    latheMesh.material = vaseMaterial;
    scene.add(latheMesh);
    setupGUI();
});

    

  
    // latheMesh = new THREE.Mesh(geometry, vaseMaterial);
    
 



    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(1, 1, 1);
    scene.add(directionalLight);

    

}

function setupGUI(){
    // GUI
    const gui = new dat.GUI();
    controlPoints.forEach((point, index) => {
        const folder = gui.addFolder(`Point ${index + 1}`);
        folder.add(point, 'y', 0, 20).onChange(updateLathe);
        folder.add(point, 'z', -40, 20).onChange(updateLathe);
        folder.open();
    });
    const folder = gui.addFolder(`Angularity`);

    folder.add({angularity: angularity}, 'angularity', 3, 25).step(1).onChange(value => {
        angularity = value;
        updateLathe();
    });

    folder.add({metalness: metalnes}, 'metalness', 0, 1).onChange(value => {
        metalnes = value;
        vaseMaterial.metalness = metalnes;
    });
    folder.add({roughness: roughness}, 'roughness', 0, 1).onChange(value => {
        roughness = value;
        vaseMaterial.roughness = roughness;
    });
    folder.add({clearcoat: clearcoat}, 'clearcoat', 0, 1).onChange(value => {
        clearcoat = value;
        vaseMaterial.clearcoat = clearcoat;
    });

    // Add GUI folder for material properties
    const materialFolder = gui.addFolder('Vase Material');

    // Object to hold the color value for GUI
    const materialColor = {
        color: `#${vaseMaterial.color.getHexString()}`, // Convert THREE.Color to hex string for dat.GUI
    };

    // Add color controller
    materialFolder.addColor(materialColor, 'color').name('Color').onChange(function(hexColor) {
        vaseMaterial.color.set(hexColor); // Update material color
    });

    

    folder.open();
}

function handleColorChange( color ) {

return function ( value ) {

    if ( typeof value === 'string' ) {

        value = value.replace( '#', '0x' );

    }

    color.setHex( value );

};

}

function updateLathe() {
    curve = new THREE.CatmullRomCurve3(controlPoints);
    const points2D = curve.getPoints(angularity).map(p => new THREE.Vector2(p.y, p.z));
    latheMesh.geometry.dispose();
    const points2DReversed = points2D.reverse();
    latheMesh.geometry = new THREE.LatheGeometry(points2DReversed, 20);
}

function animate() {
    requestAnimationFrame(animate);
    latheMesh.rotation.y += 0.01; // Add some rotation to the lathe object to view it from different angles
    controls.update(); 

    renderer.render(scene, camera);
}

    </script>
 

     
</body>
</html>
